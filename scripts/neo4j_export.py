"""Export Neo4j database to a restorable Cypher script.

Reads all nodes and relationships through the driver's transaction layer,
which guarantees the export reflects committed state (safe on a running db).

Usage:
    uv run python scripts/neo4j_export.py [output_dir]
"""

from __future__ import annotations

import os
import sys
from datetime import datetime
from pathlib import Path

from neo4j import GraphDatabase


def _cypher_literal(value) -> str:
    """Convert a Python value to a Cypher literal string."""
    if value is None:
        return "null"
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, (int, float)):
        return repr(value)
    if isinstance(value, str):
        escaped = value.replace("\\", "\\\\").replace("'", "\\'").replace("\n", "\\n")
        return f"'{escaped}'"
    if isinstance(value, list):
        items = ", ".join(_cypher_literal(v) for v in value)
        return f"[{items}]"
    if isinstance(value, dict):
        items = ", ".join(f"{k}: {_cypher_literal(v)}" for k, v in value.items())
        return "{" + items + "}"
    # datetime, date, etc. from neo4j driver
    return f"'{value}'"


def _props_string(props: dict) -> str:
    """Build a Cypher property map string from a dict."""
    if not props:
        return ""
    pairs = []
    for k, v in props.items():
        pairs.append(f"{k}: {_cypher_literal(v)}")
    return " {" + ", ".join(pairs) + "}"


def _labels_string(labels: list[str]) -> str:
    """Build :Label1:Label2 string."""
    return "".join(f":{lbl}" for lbl in labels)


def _find_id_key(labels: list[str], props: dict) -> tuple[str, str] | None:
    """Find the best property to use as a node identifier for MERGE.

    Returns (key_name, cypher_literal_value) or None.
    """
    # Priority order of ID properties
    candidates = [
        "evaluation_id",
        "agent_id",
        "id",
        "pattern_id",
        "name",
        "question_id",
        "exam_id",
    ]
    for key in candidates:
        if key in props:
            return key, _cypher_literal(props[key])
    # Fallback: first property
    if props:
        key = next(iter(props))
        return key, _cypher_literal(props[key])
    return None


def export(uri: str, user: str, password: str, output_dir: Path) -> Path:
    """Export full database to a .cypher file. Returns the output path."""
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    outfile = output_dir / f"neo4j-backup-{timestamp}.cypher"

    driver = GraphDatabase.driver(uri, auth=(user, password))
    driver.verify_connectivity()

    lines: list[str] = []
    lines.append(f"// Neo4j backup {timestamp}")
    lines.append("// Generated by scripts/neo4j_export.py")
    lines.append("// Restore: pipe into cypher-shell")
    lines.append("")

    # ── Schema: constraints ────────────────────────────────────────
    lines.append("// ── Constraints ──")
    records, _, _ = driver.execute_query(
        "SHOW CONSTRAINTS YIELD name, type, labelsOrTypes, properties RETURN *"
    )
    for r in records:
        name = r["name"]
        lbl = r["labelsOrTypes"][0]
        props = ", ".join(f"n.{p}" for p in r["properties"])
        kind = r["type"]
        if kind == "UNIQUENESS":
            lines.append(
                f"CREATE CONSTRAINT {name} IF NOT EXISTS "
                f"FOR (n:{lbl}) REQUIRE ({props}) IS UNIQUE;"
            )
        elif kind == "NODE_KEY":
            lines.append(
                f"CREATE CONSTRAINT {name} IF NOT EXISTS "
                f"FOR (n:{lbl}) REQUIRE ({props}) IS NODE KEY;"
            )
    lines.append("")

    # ── Schema: indexes (skip lookup and constraint-backing) ───────
    lines.append("// ── Indexes ──")
    records, _, _ = driver.execute_query(
        "SHOW INDEXES YIELD name, type, labelsOrTypes, properties, owningConstraint "
        "WHERE type <> 'LOOKUP' AND owningConstraint IS NULL RETURN *"
    )
    for r in records:
        name = r["name"]
        idx_type = r["type"]
        lbl = r["labelsOrTypes"][0]
        props = ", ".join(f"n.{p}" for p in r["properties"])
        if idx_type == "VECTOR":
            # Vector indexes need special syntax, skip for now
            lines.append(f"// SKIP vector index: {name}")
        else:
            lines.append(
                f"CREATE {idx_type} INDEX {name} IF NOT EXISTS "
                f"FOR (n:{lbl}) ON ({props});"
            )
    lines.append("")

    # ── Nodes ──────────────────────────────────────────────────────
    lines.append("// ── Nodes ──")
    records, _, _ = driver.execute_query(
        "MATCH (n) RETURN labels(n) AS labels, properties(n) AS props, "
        "elementId(n) AS eid ORDER BY eid"
    )

    # Map elementId to a MERGE-friendly identifier for relationship export
    node_id_map: dict[str, tuple[str, str, str]] = {}  # eid -> (label, key, val)

    node_count = 0
    for r in records:
        labels = r["labels"]
        props = r["props"]
        id_info = _find_id_key(labels, props)
        if id_info:
            node_id_map[r["eid"]] = (labels[0], id_info[0], id_info[1])

        lbl_str = _labels_string(labels)
        prop_str = _props_string(props)
        lines.append(f"MERGE (n{lbl_str}{prop_str});")
        node_count += 1

    lines.append(f"// {node_count} nodes exported")
    lines.append("")

    # ── Relationships ──────────────────────────────────────────────
    lines.append("// ── Relationships ──")
    records, _, _ = driver.execute_query(
        "MATCH (a)-[r]->(b) "
        "RETURN elementId(a) AS a_eid, elementId(b) AS b_eid, "
        "type(r) AS rel_type, properties(r) AS rel_props "
        "ORDER BY a_eid, b_eid"
    )

    rel_count = 0
    skipped = 0
    for r in records:
        a_info = node_id_map.get(r["a_eid"])
        b_info = node_id_map.get(r["b_eid"])
        if not a_info or not b_info:
            skipped += 1
            continue

        a_label, a_key, a_val = a_info
        b_label, b_key, b_val = b_info
        rel_type = r["rel_type"]
        rel_props = _props_string(r["rel_props"])

        lines.append(
            f"MATCH (a:{a_label} {{{a_key}: {a_val}}}), "
            f"(b:{b_label} {{{b_key}: {b_val}}}) "
            f"MERGE (a)-[:{rel_type}{rel_props}]->(b);"
        )
        rel_count += 1

    lines.append(f"// {rel_count} relationships exported ({skipped} skipped)")

    driver.close()

    # ── Write file ─────────────────────────────────────────────────
    outfile.write_text("\n".join(lines) + "\n")
    print(f"Neo4j backup saved: {outfile} ({node_count} nodes, {rel_count} rels)")
    return outfile


def main():
    output_dir = Path(sys.argv[1]) if len(sys.argv) > 1 else Path("backups")
    output_dir.mkdir(parents=True, exist_ok=True)

    uri = os.environ.get("NEO4J_URI", "bolt://localhost:7694")
    user = os.environ.get("NEO4J_USER", "neo4j")
    password = os.environ.get("NEO4J_PASSWORD", "password")

    try:
        export(uri, user, password, output_dir)
    except Exception as exc:
        print(f"ERROR: Neo4j backup failed: {exc}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
